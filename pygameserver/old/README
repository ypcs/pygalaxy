=Distributed Application State=

This module allows your Python programs to easily have a persistent
global distributed state.  This state can be used to store things like
number of users, game high scores, message of the day from the author,
etc.

Your application state is limited to 100K after being serialized and
encoded.  You can check the size of your state using:
len(serialize(yourstate)).

==How to use==

First you need to initialize the connection to Google App Engine.  Do
this by calling init(appid=...) with an application id that is unique
to your application.  Every instance of your application will use
the same application id.
    
Recommended naming scheme for appid: 
(your name OR your domain name) PLUS application name

So one of my hypothetical application ids is:
NathanWhitehead+AstroMaxBlaster

The simplest way to use the distributed state after you've called
init() is to use get_state() and set_state() the change the state.

===Message of the Day===

A very simple example is a 'message of the day' feature.  This
application retrieves the state and displays it.

{{{
import appstate

appstate.init('testing+motd')
motd = appstate.get_state()
print motd
# now do rest of application
}}}

You, the author of the application, then set the message of the day
every day with:

{{{
import appstate

appstate.init('testing+motd')
appstate.set_state('Version 2.7 just came out!!  New features!')
}}}

===Updating state===

Just using get_state() and set_state() is not a good idea for
applications that will have more than one person updating the state.
For example, suppose the state is just a number representing how many
times the application has been run anywhere.  When the application
starts up it might run something like set_state(get_state() + 1).

But what if two different people run the application at the same
time?  Both of them evaluate get_state() and get 102.  They both
increment to get 103, then they both set the state to 103.  But
that's wrong, the count should go to 104 since two copies of the
application started.

Here's the BAD counting application:
{{{
import appstate

appstate.init('testing+counter')

def incr_count():
    try:
        old = appstate.get_state()
        new = old + 1
        appstate.set_state(new)
        return new
    except appstate.NoStateSet:
        appstate.set_state(1)
        return 1

print incr_count()
}}}

In Linux you can see the bad behavior by running two copies simultaneously:
{{{
python test/counter_bad.py & python test/counter_bad.py &
}}}

The solution is to use update_state().  When you call update_state()
you give a hash of the previous version of the state you are updating
along with your new state.  If everything goes well the state will
update.  If someone else has beaten you to changing the state, the
hash value you passed will not match and the function will raise a
exception UpdateFailed.  You can get the new state and try again.

For the example, both applications try to update from 102->103.
One of them succeeds but the other one has to fail.  The one
that fails rereads the count (103), increments it to 104,
and then tries to update 103->104.  If no one else has beaten
the application again then the update will succeed.

Here's the GOOD counting application:
{{{
import appstate

appstate.init('testing+counter')

def incr_count():
    try:
        old = appstate.get_state()
        new = old + 1
        oldhash = appstate.hash(appstate.serialize(old))
        appstate.update_state(oldhash, new)
        return new
    except appstate.UpdateFailed:
        return incr_count() # try again
    except appstate.NoStateSet:
        appstate.set_state(1)
        return 1

print incr_count()
}}}

===Unique IDs===

It is a good idea to give every instance of the application a different
identifier.  This way the global state can include 


==Security==

NOTE THAT THERE IS NO SECURITY!

There is no security.  Users of your application do not need accounts
to update the distributed state.  This means that users may change the
state to any value.  If you are using the state to record high scores,
players can hack your program and give themselves the high score.

A future version of this module may have more sophisticated security
features.  Until then, think of this package like Wikipedia.  The
point is to allow people to collaborate and do something cool with a 
minimum amount of distruption due to morons.  To that end, use the
'backup' command line option to save the application state often.
Use the 'restore' command to revert the state to a previous value
if you see any malicious activity.

An implication: you should NEVER put python code into the state
and then evaluate it.  You should NEVER put text into the state
that will in any way be interpreted as characters going to a shell.
In general, be PARANOID about interpretting data in the state.

